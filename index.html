<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RNG Spinner ‚Äî modern VFX</title>
  <!-- Tailwind (CDN build) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="description" content="A clean RNG spinner game with smooth VFX. Single-file, deploy anywhere." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%23111'/%3E%3Cpath d='M32 5 A27 27 0 1 0 59 32' fill='%23a855f7'/%3E%3C/svg%3E" />
  <style>
    html, body { height: 100%; }
    /* subtle noise */
    .noise::after {
      content: "";
      position: absolute; inset: 0; pointer-events: none; opacity: .08; mix-blend-mode: soft-light;
      background-image: url('data:image/svg+xml;utf8,\
        <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 60 60">\
          <filter id="n">\
            <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch"/>\
            <feComponentTransfer>\
              <feFuncA type="linear" slope="0.4"/>\
            </feComponentTransfer>\
          </filter>\
          <rect width="60" height="60" filter="url(%23n)" opacity="0.18"/>\
        </svg>');
    }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950 text-slate-100 relative overflow-hidden">
  <!-- background glows -->
  <div class="pointer-events-none absolute inset-0">
    <div class="absolute -top-24 -left-24 w-[420px] h-[420px] rounded-full bg-fuchsia-600/20 blur-3xl"></div>
    <div class="absolute top-1/2 -right-24 w-[520px] h-[520px] rounded-full bg-indigo-500/20 blur-3xl"></div>
    <div class="absolute bottom-0 left-1/3 right-1/3 h-px bg-gradient-to-r from-transparent via-white/20 to-transparent"></div>
  </div>

  <div id="root" class="relative"></div>

  <!-- React 18 UMD + Babel for in-browser JSX (easy GitHub Pages deploy) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // --- Utility: seeded RNG (optional fairness/replayability) ---
    function mulberry32(seed) {
      return function () {
        let t = (seed += 0x6d2b79f5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    // --- Particle system for confetti ---
    class Particle {
      constructor(x, y) {
        this.x = x; this.y = y;
        const a = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        this.vx = Math.cos(a) * speed;
        this.vy = Math.sin(a) * speed - 2;
        this.life = 0; this.ttl = 60 + Math.random() * 40;
        this.size = 2 + Math.random() * 3;
        this.hue = Math.floor(Math.random() * 360);
      }
      step(ctx) {
        this.life++;
        this.x += this.vx; this.y += this.vy;
        this.vy += 0.1;
        ctx.globalAlpha = 1 - this.life / this.ttl;
        ctx.fillStyle = `hsl(${this.hue} 80% 60%)`;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
        return this.life < this.ttl;
      }
    }

    // --- Tiny synth beep ---
    const playBeep = (win = false) => {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = win ? "triangle" : "sine";
        o.frequency.setValueAtTime(win ? 740 : 420, ctx.currentTime);
        g.gain.setValueAtTime(0.0001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.06, ctx.currentTime + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + (win ? 0.35 : 0.15));
        o.connect(g).connect(ctx.destination); o.start(); o.stop(ctx.currentTime + (win ? 0.4 : 0.18));
      } catch {}
    };

    const DEFAULT_SEGMENTS = [
      { id: "s1", label: "Common",    weight: 42, color: "#9CA3AF", icon: "‚¨§", payout: 5 },
      { id: "s2", label: "Uncommon",  weight: 26, color: "#34D399", icon: "‚óÜ", payout: 10 },
      { id: "s3", label: "Rare",      weight: 16, color: "#60A5FA", icon: "‚òÖ", payout: 20 },
      { id: "s4", label: "Epic",      weight: 10, color: "#A78BFA", icon: "‚ú¶", payout: 40 },
      { id: "s5", label: "Legendary", weight: 5,  color: "#F59E0B", icon: "‚úØ", payout: 100 },
      { id: "s6", label: "Mythic",    weight: 1,  color: "#EF4444", icon: "‚ú™", payout: 250 },
    ];

    function pickWeightedIndex(weights, rng) {
      const sum = weights.reduce((a,b)=>a+b,0); let r = rng()*sum;
      for (let i=0;i<weights.length;i++){ r -= weights[i]; if (r <= 0) return i; }
      return weights.length-1;
    }

    function buildAngles(segments) {
      const total = segments.reduce((acc, s) => acc + s.weight, 0);
      let start = -Math.PI/2; // pointer at top
      return segments.map(s => { const angle = (s.weight/total)*Math.PI*2; const a0=start; const a1=start+angle; start=a1; return {a0,a1}; });
    }

    function App(){
      const [segments, setSegments] = useState(DEFAULT_SEGMENTS);
      const [seed, setSeed] = useState("");
      const rng = useMemo(() => (seed ? mulberry32([...seed].reduce((a,c)=>a+c.charCodeAt(0),0)) : Math.random), [seed]);

      const [spinning, setSpinning] = useState(false);
      const [rotation, setRotation] = useState(0);
      const [spinPower, setSpinPower] = useState(0.8);
      const [soundOn, setSoundOn] = useState(true);
      const [result, setResult] = useState(null);
      const [score, setScore] = useState(0);
      const [history, setHistory] = useState([]);

      const canvasRef = useRef(null);
      const particles = useRef([]);
      const rafRef = useRef(null);

      useEffect(()=>{
        const canvas = canvasRef.current; if(!canvas) return; const ctx = canvas.getContext('2d'); if(!ctx) return;
        const render=()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); particles.current = particles.current.filter(p=>p.step(ctx)); rafRef.current = requestAnimationFrame(render); };
        rafRef.current = requestAnimationFrame(render);
        return ()=>{ if(rafRef.current) cancelAnimationFrame(rafRef.current); };
      },[]);

      useEffect(()=>{
        const onResize=()=>{
          const canvas = canvasRef.current; if(!canvas) return; const rect = canvas.parentElement.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1; canvas.width = rect.width*dpr; canvas.height = rect.height*dpr; canvas.style.width = rect.width+"px"; canvas.style.height = rect.height+"px";
        }; onResize(); window.addEventListener('resize', onResize); return ()=>window.removeEventListener('resize', onResize);
      },[]);

      const angles = useMemo(()=>buildAngles(segments),[segments]);

      const spin = () => {
        if (spinning) return; setResult(null); setSpinning(true);
        const idx = pickWeightedIndex(segments.map(s=>s.weight), typeof rng === 'function' ? rng : Math.random);
        const { a0, a1 } = angles[idx];
        const middle = (a0+a1)/2; const middleDeg = middle*180/Math.PI;
        const turns = 6 + Math.floor((spinPower - 0.2) * 6); // 6..12
        const jitter = (Math.random()*6 - 3);
        const target = turns*360 + (90 - middleDeg) + jitter; // pointer at top
        const start = rotation % 360; const end = start + target;
        const duration = 2000 + spinPower*1200; const t0 = performance.now();
        const step=(t)=>{
          const p = Math.min(1, (t - t0)/duration); const eased = 1 - Math.pow(1-p,3); const value = start + (end-start)*eased;
          setRotation(value);
          if (soundOn && p<1 && Math.random()<0.05) playBeep(false);
          if (p<1) requestAnimationFrame(step); else {
            const landed = segments[idx]; setResult(landed); setHistory(h=>[landed,...h].slice(0,12)); setScore(s=>s+(landed.payout||0)); if (soundOn) playBeep(true);
            const canvas = canvasRef.current; const rect = canvas?.getBoundingClientRect?.();
            if (canvas && rect) { const dpr = window.devicePixelRatio || 1; for(let i=0;i<120;i++) particles.current.push(new Particle(rect.width*dpr/2, 40*dpr)); }
            setSpinning(false);
          }
        }; requestAnimationFrame(step);
      };

      const reset = ()=>{ setRotation(0); setHistory([]); setScore(0); setResult(null); };

      const updateSegment=(i,patch)=>{ setSegments(prev=>{ const c=[...prev]; c[i] = {...c[i], ...patch}; return c; }); };

      const r = 160; const center = {x:r,y:r};
      const wheel = (
        <svg width={r*2} height={r*2} viewBox={`0 0 ${r*2} ${r*2}`} className="drop-shadow-2xl rounded-full select-none">
          <defs>
            <radialGradient id="gloss" cx="50%" cy="40%" r="65%">
              <stop offset="0%" stopColor="#ffffff" stopOpacity="0.15" />
              <stop offset="60%" stopColor="#ffffff" stopOpacity="0.05" />
              <stop offset="100%" stopColor="#ffffff" stopOpacity="0.0" />
            </radialGradient>
          </defs>
          {segments.map((s,i)=>{
            const {a0,a1}=angles[i]; const largeArc = (a1-a0)>Math.PI?1:0; const x0=center.x + r*Math.cos(a0); const y0=center.y + r*Math.sin(a0); const x1=center.x + r*Math.cos(a1); const y1=center.y + r*Math.sin(a1);
            const d = `M ${center.x} ${center.y} L ${x0} ${y0} A ${r} ${r} 0 ${largeArc} 1 ${x1} ${y1} Z`;
            const tx = (Math.cos((a0+a1)/2)*r)/1.6; const ty = (Math.sin((a0+a1)/2)*r)/1.6; const rot = ((a0+a1)/2)*180/Math.PI;
            return (
              <g key={s.id}>
                <path d={d} fill={s.color} />
                <g transform={`translate(${center.x},${center.y})`}>
                  <text x={tx} y={ty} textAnchor="middle" dominantBaseline="middle" className="fill-white" style={{fontSize:12,fontWeight:700}} transform={`rotate(${rot} ${tx} ${ty})`}>
                    {s.icon} {s.label}
                  </text>
                </g>
              </g>
            );
          })}
          <circle cx={center.x} cy={center.y} r={r} fill="url(#gloss)" />
          <circle cx={center.x} cy={center.y} r={10} fill="#111827" />
        </svg>
      );

      const pointer = (
        <div className="absolute -top-3 left-1/2 -translate-x-1/2">
          <div className="w-0 h-0 border-l-8 border-r-8 border-b-[16px] border-l-transparent border-r-transparent border-b-white drop-shadow-[0_2px_6px_rgba(0,0,0,0.35)]" />
        </div>
      );

      return (
        <div className="max-w-6xl mx-auto p-6 md:p-10 relative noise">
          <header className="flex items-center justify-between mb-6">
            <div className="flex items-center gap-3">
              <div className="w-9 h-9 rounded-xl bg-white/10 flex items-center justify-center backdrop-blur">üé∞</div>
              <h1 className="text-2xl md:text-3xl font-extrabold tracking-tight">RNG Spinner</h1>
              <span className="text-xs text-white/50 px-2.5 py-1 rounded-full border border-white/10">modern ‚Ä¢ smooth ‚Ä¢ fair</span>
            </div>
            <div className="flex items-center gap-3">
              <label className="flex items-center gap-2 text-sm text-white/70">
                <span className="inline-flex items-center gap-1">‚öôÔ∏è seed</span>
                <input value={seed} onChange={e=>setSeed(e.target.value)} placeholder="optional seed" className="h-8 w-[160px] bg-white/5 border border-white/10 rounded-md px-2 text-sm placeholder:text-white/30 outline-none focus:ring-2 focus:ring-fuchsia-400/40" />
              </label>
              <button onClick={reset} className="h-9 px-3 rounded-md bg-white/10 hover:bg-white/20 border border-white/10 text-sm">‚ü≤ reset</button>
            </div>
          </header>

          <div className="grid md:grid-cols-2 gap-6 items-stretch">
            <div className="relative overflow-hidden rounded-2xl bg-white/5 border border-white/10 backdrop-blur-xl">
              <div className="p-4 border-b border-white/10 text-lg font-semibold">wheel</div>
              <div className="relative flex flex-col items-center justify-center pt-2 pb-6">
                <canvas ref={canvasRef} className="absolute inset-0 pointer-events-none" />
                {pointer}
                <div className="rounded-full p-4 shadow-[0_0_40px_rgba(255,255,255,0.15)]" style={{ filter: spinning ? 'brightness(1.08)' : 'brightness(1)' }}>
                  <div style={{ transform: `rotate(${rotation}deg)` }}>
                    {wheel}
                  </div>
                </div>
                <div className="mt-6 flex items-center gap-3">
                  <button disabled={spinning} onClick={spin} className={`px-8 h-11 rounded-lg text-base text-white shadow-xl bg-gradient-to-br from-indigo-500 to-fuchsia-500 hover:brightness-110 ${spinning? 'opacity-70 cursor-not-allowed':''}`}>
                    {spinning ? 'spinning‚Ä¶' : 'spin'}
                  </button>
                  <label className="flex items-center gap-2 text-sm text-white/70 select-none">
                    <span>sound</span>
                    <input type="checkbox" checked={soundOn} onChange={e=>setSoundOn(e.target.checked)} className="accent-fuchsia-400" />
                  </label>
                </div>
                <div className="w-full mt-4">
                  <label className="text-xs uppercase tracking-widest text-white/60">spin power</label>
                  <div className="flex items-center gap-4">
                    <input type="range" min="0.2" max="1.2" step="0.05" value={spinPower} onChange={e=>setSpinPower(parseFloat(e.target.value))} className="w-full" />
                    <span className="text-sm tabular-nums text-white/70 w-10 text-right">{spinPower.toFixed(2)}</span>
                  </div>
                </div>
              </div>
            </div>

            <div className="grid gap-6">
              <div className="rounded-2xl bg-white/5 border border-white/10 backdrop-blur-xl">
                <div className="p-4 border-b border-white/10 text-lg font-semibold">payout & weights</div>
                <div className="p-4">
                  <div className="grid grid-cols-6 gap-2 text-xs text-white/60 px-1">
                    <div>label</div><div>icon</div><div>weight</div><div>payout</div><div>color</div><div></div>
                  </div>
                  <div className="max-h-56 overflow-auto pr-1">
                    {segments.map((s,i)=> (
                      <div key={s.id} className="grid grid-cols-6 gap-2 items-center py-2 border-t border-white/5">
                        <input value={s.label} onChange={e=>updateSegment(i,{label:e.target.value})} className="h-8 bg-white/5 border border-white/10 rounded px-2" />
                        <input value={s.icon||""} onChange={e=>updateSegment(i,{icon:e.target.value})} className="h-8 bg-white/5 border border-white/10 rounded px-2" />
                        <input type="number" value={s.weight} onChange={e=>updateSegment(i,{weight:Math.max(0, Number(e.target.value))})} className="h-8 bg-white/5 border border-white/10 rounded px-2" />
                        <input type="number" value={s.payout||0} onChange={e=>updateSegment(i,{payout:Number(e.target.value)})} className="h-8 bg-white/5 border border-white/10 rounded px-2" />
                        <input type="text" value={s.color} onChange={e=>updateSegment(i,{color:e.target.value})} className="h-8 bg-white/5 border border-white/10 rounded px-2" />
                        <div className="flex items-center justify-end">
                          <div className="w-6 h-6 rounded-full border border-white/20" style={{background:s.color}}></div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              <div className="rounded-2xl bg-white/5 border border-white/10 backdrop-blur-xl">
                <div className="p-4 border-b border-white/10 text-lg font-semibold">session</div>
                <div className="p-4">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2"><span>üèÜ</span><span className="text-sm text-white/80">score</span></div>
                    <div className="text-xl font-bold tabular-nums">{score}</div>
                  </div>
                  <div className="mt-4 text-xs uppercase tracking-wider text-white/60">recent pulls</div>
                  <div className="mt-2 flex flex-wrap gap-2 min-h-10">
                    {history.length === 0 ? (
                      <span className="text-white/40">no spins yet</span>
                    ) : (
                      history.map((h, idx) => (
                        <span key={idx} className="px-2 py-1 rounded-full border border-white/10 text-xs" style={{ background: `${h.color}22` }} title={`+${h.payout||0} points`}>
                          {h.icon} {h.label}
                        </span>
                      ))
                    )}
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Result toast */}
          {result && (
            <div className="fixed bottom-6 left-1/2 -translate-x-1/2 px-5 py-3 rounded-2xl bg-white/10 border border-white/15 backdrop-blur-xl shadow-2xl flex items-center gap-3">
              <span className="text-2xl" aria-hidden>{result.icon}</span>
              <div className="leading-none">
                <div className="text-sm text-white/70">you hit</div>
                <div className="text-lg font-bold">{result.label}</div>
              </div>
              <div className="ml-4 text-sm text-white/70">+{result.payout||0} pts</div>
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
